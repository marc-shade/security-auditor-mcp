"""
Test vulnerability detection functionality
"""

import pytest
from security_auditor import Severity


class TestSQLInjectionDetection:
    """Test SQL injection vulnerability detection"""

    @pytest.mark.asyncio
    async def test_detect_string_concatenation_sql(self, auditor, temp_dir, vulnerable_sql_code):
        """Should detect SQL injection via string concatenation"""
        test_file = temp_dir / "sql_vuln.py"
        test_file.write_text(vulnerable_sql_code)
        
        vulns = await auditor.scan_codebase(str(test_file))
        
        assert len(vulns) > 0
        sql_vulns = [v for v in vulns if 'sql' in v.description.lower()]
        assert len(sql_vulns) > 0
        assert sql_vulns[0].severity == Severity.CRITICAL

    @pytest.mark.asyncio
    async def test_safe_parameterized_queries(self, auditor, temp_dir, safe_sql_code):
        """Should not flag parameterized queries"""
        test_file = temp_dir / "safe_sql.py"
        test_file.write_text(safe_sql_code)
        
        vulns = await auditor.scan_codebase(str(test_file))
        
        sql_vulns = [v for v in vulns if 'sql' in v.description.lower()]
        assert len(sql_vulns) == 0

    @pytest.mark.asyncio
    async def test_multiple_sql_patterns(self, auditor, temp_dir, security_test_cases):
        """Test various SQL injection patterns"""
        for code, should_detect in security_test_cases['sql_injection_cases']:
            test_file = temp_dir / "test.py"
            test_file.write_text(code)
            
            vulns = await auditor.scan_codebase(str(test_file))
            sql_vulns = [v for v in vulns if 'sql' in v.description.lower()]
            
            if should_detect:
                assert len(sql_vulns) > 0, f"Failed to detect: {code}"
            else:
                assert len(sql_vulns) == 0, f"False positive: {code}"


class TestCommandInjectionDetection:
    """Test command injection vulnerability detection"""

    @pytest.mark.asyncio
    async def test_detect_shell_true_injection(self, auditor, temp_dir, vulnerable_command_code):
        """Should detect command injection with shell=True"""
        test_file = temp_dir / "cmd_vuln.py"
        test_file.write_text(vulnerable_command_code)
        
        vulns = await auditor.scan_codebase(str(test_file))
        
        cmd_vulns = [v for v in vulns if 'command' in v.description.lower()]
        assert len(cmd_vulns) > 0
        assert any(v.severity == Severity.CRITICAL for v in cmd_vulns)

    @pytest.mark.asyncio
    async def test_command_injection_patterns(self, auditor, temp_dir, security_test_cases):
        """Test various command injection patterns"""
        for code, should_detect in security_test_cases['command_injection_cases']:
            test_file = temp_dir / "test.py"
            test_file.write_text(code)
            
            vulns = await auditor.scan_codebase(str(test_file))
            cmd_vulns = [v for v in vulns if 'command' in v.description.lower()]
            
            if should_detect:
                assert len(cmd_vulns) > 0, f"Failed to detect: {code}"


class TestPathTraversalDetection:
    """Test path traversal vulnerability detection"""

    @pytest.mark.asyncio
    async def test_detect_path_traversal(self, auditor, temp_dir, vulnerable_path_traversal):
        """Should detect path traversal vulnerabilities"""
        test_file = temp_dir / "path_vuln.py"
        test_file.write_text(vulnerable_path_traversal)
        
        vulns = await auditor.scan_codebase(str(test_file))
        
        path_vulns = [v for v in vulns if 'path' in v.description.lower()]
        assert len(path_vulns) > 0
        assert path_vulns[0].severity == Severity.HIGH

    @pytest.mark.asyncio
    async def test_path_traversal_patterns(self, auditor, temp_dir, security_test_cases):
        """Test various path traversal patterns"""
        for code, should_detect in security_test_cases['path_traversal_cases']:
            test_file = temp_dir / "test.py"
            test_file.write_text(code)
            
            vulns = await auditor.scan_codebase(str(test_file))
            path_vulns = [v for v in vulns if 'path' in v.description.lower()]
            
            if should_detect:
                assert len(path_vulns) > 0, f"Failed to detect: {code}"


class TestHardcodedSecretsDetection:
    """Test hardcoded credentials detection"""

    @pytest.mark.asyncio
    async def test_detect_hardcoded_secrets(self, auditor, temp_dir, hardcoded_secrets):
        """Should detect hardcoded credentials"""
        test_file = temp_dir / "secrets.py"
        test_file.write_text(hardcoded_secrets)
        
        vulns = await auditor.scan_codebase(str(test_file))
        
        secret_vulns = [v for v in vulns if 'credential' in v.description.lower()]
        assert len(secret_vulns) >= 2  # Should detect multiple secrets
        assert all(v.severity == Severity.CRITICAL for v in secret_vulns)

    @pytest.mark.asyncio
    async def test_secrets_patterns(self, auditor, temp_dir, security_test_cases):
        """Test various hardcoded secret patterns"""
        for code, should_detect in security_test_cases['secrets_cases']:
            test_file = temp_dir / "test.py"
            test_file.write_text(code)
            
            vulns = await auditor.scan_codebase(str(test_file))
            secret_vulns = [v for v in vulns if 'credential' in v.description.lower()]
            
            if should_detect:
                assert len(secret_vulns) > 0, f"Failed to detect: {code}"
            else:
                assert len(secret_vulns) == 0, f"False positive: {code}"


class TestWeakCryptographyDetection:
    """Test weak cryptography detection"""

    @pytest.mark.asyncio
    async def test_detect_weak_crypto(self, auditor, temp_dir, weak_crypto_code):
        """Should detect weak cryptographic algorithms"""
        test_file = temp_dir / "crypto.py"
        test_file.write_text(weak_crypto_code)
        
        vulns = await auditor.scan_codebase(str(test_file))
        
        crypto_vulns = [v for v in vulns if 'crypto' in v.description.lower()]
        assert len(crypto_vulns) >= 2  # MD5 and SHA1
        assert all(v.severity == Severity.MEDIUM for v in crypto_vulns)

    @pytest.mark.asyncio
    async def test_crypto_patterns(self, auditor, temp_dir, security_test_cases):
        """Test various weak crypto patterns"""
        for code, should_detect in security_test_cases['crypto_cases']:
            test_file = temp_dir / "test.py"
            test_file.write_text(code)
            
            vulns = await auditor.scan_codebase(str(test_file))
            crypto_vulns = [v for v in vulns if 'crypto' in v.description.lower()]
            
            if should_detect:
                assert len(crypto_vulns) > 0, f"Failed to detect: {code}"
            else:
                assert len(crypto_vulns) == 0, f"False positive: {code}"


class TestMultiFileScanning:
    """Test scanning multiple files and directories"""

    @pytest.mark.asyncio
    async def test_scan_directory(self, auditor, mixed_codebase):
        """Should scan all files in directory"""
        vulns = await auditor.scan_codebase(str(mixed_codebase))
        
        assert len(vulns) > 0
        # Should find vulnerabilities in multiple files
        unique_files = set(v.file_path for v in vulns)
        assert len(unique_files) > 1

    @pytest.mark.asyncio
    async def test_scan_single_file(self, auditor, temp_dir, vulnerable_sql_code):
        """Should scan single file"""
        test_file = temp_dir / "single.py"
        test_file.write_text(vulnerable_sql_code)
        
        vulns = await auditor.scan_codebase(str(test_file))
        
        assert len(vulns) > 0
        assert all(v.file_path == str(test_file) for v in vulns)

    @pytest.mark.asyncio
    async def test_nonexistent_path(self, auditor):
        """Should handle nonexistent paths gracefully"""
        vulns = await auditor.scan_codebase("/nonexistent/path")
        
        assert len(vulns) == 0  # Should return empty list, not crash


class TestVulnerabilityDetails:
    """Test vulnerability object details"""

    @pytest.mark.asyncio
    async def test_vulnerability_contains_line_number(self, auditor, temp_dir, vulnerable_sql_code):
        """Vulnerability should include accurate line numbers"""
        test_file = temp_dir / "test.py"
        test_file.write_text(vulnerable_sql_code)
        
        vulns = await auditor.scan_codebase(str(test_file))
        
        assert all(v.line_number > 0 for v in vulns)

    @pytest.mark.asyncio
    async def test_vulnerability_contains_code_snippet(self, auditor, temp_dir, vulnerable_sql_code):
        """Vulnerability should include code snippet"""
        test_file = temp_dir / "test.py"
        test_file.write_text(vulnerable_sql_code)
        
        vulns = await auditor.scan_codebase(str(test_file))
        
        assert all(v.code_snippet is not None for v in vulns)
        assert all(len(v.code_snippet) > 0 for v in vulns)

    @pytest.mark.asyncio
    async def test_vulnerability_has_cwe_id(self, auditor, temp_dir, vulnerable_sql_code):
        """Vulnerability should include CWE ID"""
        test_file = temp_dir / "test.py"
        test_file.write_text(vulnerable_sql_code)
        
        vulns = await auditor.scan_codebase(str(test_file))
        
        assert all(v.cwe_id is not None for v in vulns)
        assert all(v.cwe_id.startswith('CWE-') for v in vulns)
